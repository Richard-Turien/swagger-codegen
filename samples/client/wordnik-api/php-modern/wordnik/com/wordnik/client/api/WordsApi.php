<?php
/**
 *  Copyright 2011 Wordnik, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
namespace com\wordnik\client\api;

use com\wordnik\client\common\APIClient;
use com\wordnik\client\model\DefinitionSearchResults;
use com\wordnik\client\model\WordObject;
use com\wordnik\client\model\WordOfTheDay;
use com\wordnik\client\model\WordSearchResults;


/**
 *
 * NOTE: This class is auto generated by the swagger code generator program. Do not edit the class manually.
 */
class WordsApi {

	function __construct(APIClient $apiClient) {
		$this->apiClient = $apiClient;
	}

	/**
	 * Searches words.
	 *
	* @param string $query Search query (required)
	* @param string $includePartOfSpeech Only include these comma-delimited parts of speech (optional)
	* @param string $excludePartOfSpeech Exclude these comma-delimited parts of speech (optional)
	* @param string $caseSensitive Search case sensitive (optional)
	* @param int $minCorpusCount Minimum corpus frequency for terms (optional)
	* @param int $maxCorpusCount Maximum corpus frequency for terms (optional)
	* @param int $minDictionaryCount Minimum number of dictionary entries for words returned (optional)
	* @param int $maxDictionaryCount Maximum dictionary definition count (optional)
	* @param int $minLength Minimum word length (optional)
	* @param int $maxLength Maximum word length (optional)
	* @param int $skip Results to skip (optional)
	* @param int $limit Maximum number of results to return (optional)
	* @return WordSearchResults
	*/
	public function searchWords($query, $includePartOfSpeech=null, $excludePartOfSpeech=null, $caseSensitive=null, $minCorpusCount=null, $maxCorpusCount=null, $minDictionaryCount=null, $maxDictionaryCount=null, $minLength=null, $maxLength=null, $skip=null, $limit=null) {

		//parse inputs
		$resourcePath = "/words.{format}/search/{query}";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($caseSensitive != null) {
			$queryParams['caseSensitive'] = $this->apiClient->toQueryValue($caseSensitive);
		}
		if($includePartOfSpeech != null) {
			$queryParams['includePartOfSpeech'] = $this->apiClient->toQueryValue($includePartOfSpeech);
		}
		if($excludePartOfSpeech != null) {
			$queryParams['excludePartOfSpeech'] = $this->apiClient->toQueryValue($excludePartOfSpeech);
		}
		if($minCorpusCount != null) {
			$queryParams['minCorpusCount'] = $this->apiClient->toQueryValue($minCorpusCount);
		}
		if($maxCorpusCount != null) {
			$queryParams['maxCorpusCount'] = $this->apiClient->toQueryValue($maxCorpusCount);
		}
		if($minDictionaryCount != null) {
			$queryParams['minDictionaryCount'] = $this->apiClient->toQueryValue($minDictionaryCount);
		}
		if($maxDictionaryCount != null) {
			$queryParams['maxDictionaryCount'] = $this->apiClient->toQueryValue($maxDictionaryCount);
		}
		if($minLength != null) {
			$queryParams['minLength'] = $this->apiClient->toQueryValue($minLength);
		}
		if($maxLength != null) {
			$queryParams['maxLength'] = $this->apiClient->toQueryValue($maxLength);
		}
		if($skip != null) {
			$queryParams['skip'] = $this->apiClient->toQueryValue($skip);
		}
		if($limit != null) {
			$queryParams['limit'] = $this->apiClient->toQueryValue($limit);
		}
		if($query != null) {
			$resourcePath = str_replace("{" . "query" . "}", $this->apiClient->toPathValue($query), $resourcePath);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'WordSearchResults');
		
	}
	
	/**
	 * Returns a specific WordOfTheDay.
	 *
	* @param string $date Fetches by date in yyyy-MM-dd (optional)
	* @return WordOfTheDay
	*/
	public function getWordOfTheDay($date=null) {

		//parse inputs
		$resourcePath = "/words.{format}/wordOfTheDay";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($date != null) {
			$queryParams['date'] = $this->apiClient->toQueryValue($date);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'WordOfTheDay');
		
	}
	
	/**
	 * Reverse dictionary search.
	 *
	* @param string $query Search term (required)
	* @param string $findSenseForWord Restricts words and finds closest sense (optional)
	* @param string $includeSourceDictionaries Only include these comma-delimited source dictionaries (optional)
	* @param string $excludeSourceDictionaries Exclude these comma-delimited source dictionaries (optional)
	* @param string $includePartOfSpeech Only include these comma-delimited parts of speech (optional)
	* @param string $excludePartOfSpeech Exclude these comma-delimited parts of speech (optional)
	* @param string $expandTerms Expand terms (optional)
	* @param string $sortBy Attribute to sort by (optional)
	* @param string $sortOrder Sort direction (optional)
	* @param int $minCorpusCount Minimum corpus frequency for terms (optional)
	* @param int $maxCorpusCount Maximum corpus frequency for terms (optional)
	* @param int $minLength Minimum word length (optional)
	* @param int $maxLength Maximum word length (optional)
	* @param string $includeTags Return a closed set of XML tags in response (optional)
	* @param string $skip Results to skip (optional)
	* @param int $limit Maximum number of results to return (optional)
	* @return DefinitionSearchResults
	*/
	public function reverseDictionary($query, $findSenseForWord=null, $includeSourceDictionaries=null, $excludeSourceDictionaries=null, $includePartOfSpeech=null, $excludePartOfSpeech=null, $expandTerms=null, $sortBy=null, $sortOrder=null, $minCorpusCount=null, $maxCorpusCount=null, $minLength=null, $maxLength=null, $includeTags=null, $skip=null, $limit=null) {

		//parse inputs
		$resourcePath = "/words.{format}/reverseDictionary";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($query != null) {
			$queryParams['query'] = $this->apiClient->toQueryValue($query);
		}
		if($findSenseForWord != null) {
			$queryParams['findSenseForWord'] = $this->apiClient->toQueryValue($findSenseForWord);
		}
		if($includeSourceDictionaries != null) {
			$queryParams['includeSourceDictionaries'] = $this->apiClient->toQueryValue($includeSourceDictionaries);
		}
		if($excludeSourceDictionaries != null) {
			$queryParams['excludeSourceDictionaries'] = $this->apiClient->toQueryValue($excludeSourceDictionaries);
		}
		if($includePartOfSpeech != null) {
			$queryParams['includePartOfSpeech'] = $this->apiClient->toQueryValue($includePartOfSpeech);
		}
		if($excludePartOfSpeech != null) {
			$queryParams['excludePartOfSpeech'] = $this->apiClient->toQueryValue($excludePartOfSpeech);
		}
		if($minCorpusCount != null) {
			$queryParams['minCorpusCount'] = $this->apiClient->toQueryValue($minCorpusCount);
		}
		if($maxCorpusCount != null) {
			$queryParams['maxCorpusCount'] = $this->apiClient->toQueryValue($maxCorpusCount);
		}
		if($minLength != null) {
			$queryParams['minLength'] = $this->apiClient->toQueryValue($minLength);
		}
		if($maxLength != null) {
			$queryParams['maxLength'] = $this->apiClient->toQueryValue($maxLength);
		}
		if($expandTerms != null) {
			$queryParams['expandTerms'] = $this->apiClient->toQueryValue($expandTerms);
		}
		if($includeTags != null) {
			$queryParams['includeTags'] = $this->apiClient->toQueryValue($includeTags);
		}
		if($sortBy != null) {
			$queryParams['sortBy'] = $this->apiClient->toQueryValue($sortBy);
		}
		if($sortOrder != null) {
			$queryParams['sortOrder'] = $this->apiClient->toQueryValue($sortOrder);
		}
		if($skip != null) {
			$queryParams['skip'] = $this->apiClient->toQueryValue($skip);
		}
		if($limit != null) {
			$queryParams['limit'] = $this->apiClient->toQueryValue($limit);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'DefinitionSearchResults');
		
	}
	
	/**
	 * Returns an array of random WordObjects.
	 *
	* @param string $includePartOfSpeech CSV part-of-speech values to include (optional)
	* @param string $excludePartOfSpeech CSV part-of-speech values to exclude (optional)
	* @param string $sortBy Attribute to sort by (optional)
	* @param string $sortOrder Sort direction (optional)
	* @param string $hasDictionaryDef Only return words with dictionary definitions (optional)
	* @param int $minCorpusCount Minimum corpus frequency for terms (optional)
	* @param int $maxCorpusCount Maximum corpus frequency for terms (optional)
	* @param int $minDictionaryCount Minimum dictionary count (optional)
	* @param int $maxDictionaryCount Maximum dictionary count (optional)
	* @param int $minLength Minimum word length (optional)
	* @param int $maxLength Maximum word length (optional)
	* @param int $limit Maximum number of results to return (optional)
	* @return array[WordObject]
	*/
	public function getRandomWords($includePartOfSpeech=null, $excludePartOfSpeech=null, $sortBy=null, $sortOrder=null, $hasDictionaryDef=null, $minCorpusCount=null, $maxCorpusCount=null, $minDictionaryCount=null, $maxDictionaryCount=null, $minLength=null, $maxLength=null, $limit=null) {

		//parse inputs
		$resourcePath = "/words.{format}/randomWords";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($hasDictionaryDef != null) {
			$queryParams['hasDictionaryDef'] = $this->apiClient->toQueryValue($hasDictionaryDef);
		}
		if($includePartOfSpeech != null) {
			$queryParams['includePartOfSpeech'] = $this->apiClient->toQueryValue($includePartOfSpeech);
		}
		if($excludePartOfSpeech != null) {
			$queryParams['excludePartOfSpeech'] = $this->apiClient->toQueryValue($excludePartOfSpeech);
		}
		if($minCorpusCount != null) {
			$queryParams['minCorpusCount'] = $this->apiClient->toQueryValue($minCorpusCount);
		}
		if($maxCorpusCount != null) {
			$queryParams['maxCorpusCount'] = $this->apiClient->toQueryValue($maxCorpusCount);
		}
		if($minDictionaryCount != null) {
			$queryParams['minDictionaryCount'] = $this->apiClient->toQueryValue($minDictionaryCount);
		}
		if($maxDictionaryCount != null) {
			$queryParams['maxDictionaryCount'] = $this->apiClient->toQueryValue($maxDictionaryCount);
		}
		if($minLength != null) {
			$queryParams['minLength'] = $this->apiClient->toQueryValue($minLength);
		}
		if($maxLength != null) {
			$queryParams['maxLength'] = $this->apiClient->toQueryValue($maxLength);
		}
		if($sortBy != null) {
			$queryParams['sortBy'] = $this->apiClient->toQueryValue($sortBy);
		}
		if($sortOrder != null) {
			$queryParams['sortOrder'] = $this->apiClient->toQueryValue($sortOrder);
		}
		if($limit != null) {
			$queryParams['limit'] = $this->apiClient->toQueryValue($limit);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'array[WordObject]');
		
	}
	
	/**
	 * Returns a single random WordObject.
	 *
	* @param string $includePartOfSpeech CSV part-of-speech values to include (optional)
	* @param string $excludePartOfSpeech CSV part-of-speech values to exclude (optional)
	* @param string $hasDictionaryDef Only return words with dictionary definitions (optional)
	* @param int $minCorpusCount Minimum corpus frequency for terms (optional)
	* @param int $maxCorpusCount Maximum corpus frequency for terms (optional)
	* @param int $minDictionaryCount Minimum dictionary count (optional)
	* @param int $maxDictionaryCount Maximum dictionary count (optional)
	* @param int $minLength Minimum word length (optional)
	* @param int $maxLength Maximum word length (optional)
	* @return WordObject
	*/
	public function getRandomWord($includePartOfSpeech=null, $excludePartOfSpeech=null, $hasDictionaryDef=null, $minCorpusCount=null, $maxCorpusCount=null, $minDictionaryCount=null, $maxDictionaryCount=null, $minLength=null, $maxLength=null) {

		//parse inputs
		$resourcePath = "/words.{format}/randomWord";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($hasDictionaryDef != null) {
			$queryParams['hasDictionaryDef'] = $this->apiClient->toQueryValue($hasDictionaryDef);
		}
		if($includePartOfSpeech != null) {
			$queryParams['includePartOfSpeech'] = $this->apiClient->toQueryValue($includePartOfSpeech);
		}
		if($excludePartOfSpeech != null) {
			$queryParams['excludePartOfSpeech'] = $this->apiClient->toQueryValue($excludePartOfSpeech);
		}
		if($minCorpusCount != null) {
			$queryParams['minCorpusCount'] = $this->apiClient->toQueryValue($minCorpusCount);
		}
		if($maxCorpusCount != null) {
			$queryParams['maxCorpusCount'] = $this->apiClient->toQueryValue($maxCorpusCount);
		}
		if($minDictionaryCount != null) {
			$queryParams['minDictionaryCount'] = $this->apiClient->toQueryValue($minDictionaryCount);
		}
		if($maxDictionaryCount != null) {
			$queryParams['maxDictionaryCount'] = $this->apiClient->toQueryValue($maxDictionaryCount);
		}
		if($minLength != null) {
			$queryParams['minLength'] = $this->apiClient->toQueryValue($minLength);
		}
		if($maxLength != null) {
			$queryParams['maxLength'] = $this->apiClient->toQueryValue($maxLength);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'WordObject');
		
	}
	
	}

