<?php
/**
 *  Copyright 2011 Wordnik, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
namespace com\wordnik\client\api;

use com\wordnik\client\common\APIClient;
use com\wordnik\client\model\FrequencySummary;
use com\wordnik\client\model\Bigram;
use com\wordnik\client\model\WordObject;
use com\wordnik\client\model\ExampleSearchResults;
use com\wordnik\client\model\Example;
use com\wordnik\client\model\ScrabbleScoreResult;
use com\wordnik\client\model\TextPron;
use com\wordnik\client\model\Syllable;
use com\wordnik\client\model\Related;
use com\wordnik\client\model\Definition;
use com\wordnik\client\model\AudioFile;


/**
 *
 * NOTE: This class is auto generated by the swagger code generator program. Do not edit the class manually.
 */
class WordApi {

	function __construct(APIClient $apiClient) {
		$this->apiClient = $apiClient;
	}

	/**
	 * Returns examples for a word.
	 *
	* @param string $word Word to return examples for (required)
	* @param string $includeDuplicates Show duplicate examples from different sources (optional)
	* @param string $useCanonical If true will try to return the correct word root ('cats' -&gt; 'cat'). If false returns exactly what was requested. (optional)
	* @param int $skip Results to skip (optional)
	* @param int $limit Maximum number of results to return (optional)
	* @return ExampleSearchResults
	*/
	public function getExamples($word, $includeDuplicates=null, $useCanonical=null, $skip=null, $limit=null) {

		//parse inputs
		$resourcePath = "/word.{format}/{word}/examples";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($includeDuplicates != null) {
			$queryParams['includeDuplicates'] = $this->apiClient->toQueryValue($includeDuplicates);
		}
		if($useCanonical != null) {
			$queryParams['useCanonical'] = $this->apiClient->toQueryValue($useCanonical);
		}
		if($skip != null) {
			$queryParams['skip'] = $this->apiClient->toQueryValue($skip);
		}
		if($limit != null) {
			$queryParams['limit'] = $this->apiClient->toQueryValue($limit);
		}
		if($word != null) {
			$resourcePath = str_replace("{" . "word" . "}", $this->apiClient->toPathValue($word), $resourcePath);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'ExampleSearchResults');
		
	}
	
	/**
	 * Given a word as a string, returns the WordObject that represents it.
	 *
	* @param string $word String value of WordObject to return (required)
	* @param string $useCanonical If true will try to return the correct word root ('cats' -&gt; 'cat'). If false returns exactly what was requested. (optional)
	* @param string $includeSuggestions Return suggestions (for correct spelling, case variants, etc.) (optional)
	* @return WordObject
	*/
	public function getWord($word, $useCanonical=null, $includeSuggestions=null) {

		//parse inputs
		$resourcePath = "/word.{format}/{word}";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($useCanonical != null) {
			$queryParams['useCanonical'] = $this->apiClient->toQueryValue($useCanonical);
		}
		if($includeSuggestions != null) {
			$queryParams['includeSuggestions'] = $this->apiClient->toQueryValue($includeSuggestions);
		}
		if($word != null) {
			$resourcePath = str_replace("{" . "word" . "}", $this->apiClient->toPathValue($word), $resourcePath);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'WordObject');
		
	}
	
	/**
	 * Return definitions for a word.
	 *
	* @param string $word Word to return definitions for (required)
	* @param string $partOfSpeech CSV list of part-of-speech types (optional)
	* @param string $sourceDictionaries Source dictionary to return definitions from.  If 'all' is received, results are returned from all sources. If multiple values are received (e.g. 'century,wiktionary'), results are returned from the first specified dictionary that has definitions. If left blank, results are returned from the first dictionary that has definitions. By default, dictionaries are searched in this order: ahd, wiktionary, webster, century, wordnet (optional)
	* @param int $limit Maximum number of results to return (optional)
	* @param string $includeRelated Return related words with definitions (optional)
	* @param string $useCanonical If true will try to return the correct word root ('cats' -&gt; 'cat'). If false returns exactly what was requested. (optional)
	* @param string $includeTags Return a closed set of XML tags in response (optional)
	* @return array[Definition]
	*/
	public function getDefinitions($word, $partOfSpeech=null, $sourceDictionaries=null, $limit=null, $includeRelated=null, $useCanonical=null, $includeTags=null) {

		//parse inputs
		$resourcePath = "/word.{format}/{word}/definitions";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($limit != null) {
			$queryParams['limit'] = $this->apiClient->toQueryValue($limit);
		}
		if($partOfSpeech != null) {
			$queryParams['partOfSpeech'] = $this->apiClient->toQueryValue($partOfSpeech);
		}
		if($includeRelated != null) {
			$queryParams['includeRelated'] = $this->apiClient->toQueryValue($includeRelated);
		}
		if($sourceDictionaries != null) {
			$queryParams['sourceDictionaries'] = $this->apiClient->toQueryValue($sourceDictionaries);
		}
		if($useCanonical != null) {
			$queryParams['useCanonical'] = $this->apiClient->toQueryValue($useCanonical);
		}
		if($includeTags != null) {
			$queryParams['includeTags'] = $this->apiClient->toQueryValue($includeTags);
		}
		if($word != null) {
			$resourcePath = str_replace("{" . "word" . "}", $this->apiClient->toPathValue($word), $resourcePath);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'array[Definition]');
		
	}
	
	/**
	 * Returns a top example for a word.
	 *
	* @param string $word Word to fetch examples for (required)
	* @param string $useCanonical If true will try to return the correct word root ('cats' -&gt; 'cat'). If false returns exactly what was requested. (optional)
	* @return Example
	*/
	public function getTopExample($word, $useCanonical=null) {

		//parse inputs
		$resourcePath = "/word.{format}/{word}/topExample";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($useCanonical != null) {
			$queryParams['useCanonical'] = $this->apiClient->toQueryValue($useCanonical);
		}
		if($word != null) {
			$resourcePath = str_replace("{" . "word" . "}", $this->apiClient->toPathValue($word), $resourcePath);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'Example');
		
	}
	
	/**
	 * Given a word as a string, returns relationships from the Word Graph.
	 *
	* @param string $word Word to fetch relationships for (required)
	* @param string $relationshipTypes Limits the total results per type of relationship type (optional)
	* @param string $useCanonical If true will try to return the correct word root ('cats' -&gt; 'cat'). If false returns exactly what was requested. (optional)
	* @param int $limitPerRelationshipType Restrict to the supplied relatinship types (optional)
	* @return array[Related]
	*/
	public function getRelatedWords($word, $relationshipTypes=null, $useCanonical=null, $limitPerRelationshipType=null) {

		//parse inputs
		$resourcePath = "/word.{format}/{word}/relatedWords";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($useCanonical != null) {
			$queryParams['useCanonical'] = $this->apiClient->toQueryValue($useCanonical);
		}
		if($relationshipTypes != null) {
			$queryParams['relationshipTypes'] = $this->apiClient->toQueryValue($relationshipTypes);
		}
		if($limitPerRelationshipType != null) {
			$queryParams['limitPerRelationshipType'] = $this->apiClient->toQueryValue($limitPerRelationshipType);
		}
		if($word != null) {
			$resourcePath = str_replace("{" . "word" . "}", $this->apiClient->toPathValue($word), $resourcePath);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'array[Related]');
		
	}
	
	/**
	 * Returns text pronunciations for a given word.
	 *
	* @param string $word Word to get pronunciations for (required)
	* @param string $sourceDictionary Get from a single dictionary (optional)
	* @param string $typeFormat Text pronunciation type (optional)
	* @param string $useCanonical If true will try to return a correct word root ('cats' -&gt; 'cat'). If false returns exactly what was requested. (optional)
	* @param int $limit Maximum number of results to return (optional)
	* @return array[TextPron]
	*/
	public function getTextPronunciations($word, $sourceDictionary=null, $typeFormat=null, $useCanonical=null, $limit=null) {

		//parse inputs
		$resourcePath = "/word.{format}/{word}/pronunciations";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($useCanonical != null) {
			$queryParams['useCanonical'] = $this->apiClient->toQueryValue($useCanonical);
		}
		if($sourceDictionary != null) {
			$queryParams['sourceDictionary'] = $this->apiClient->toQueryValue($sourceDictionary);
		}
		if($typeFormat != null) {
			$queryParams['typeFormat'] = $this->apiClient->toQueryValue($typeFormat);
		}
		if($limit != null) {
			$queryParams['limit'] = $this->apiClient->toQueryValue($limit);
		}
		if($word != null) {
			$resourcePath = str_replace("{" . "word" . "}", $this->apiClient->toPathValue($word), $resourcePath);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'array[TextPron]');
		
	}
	
	/**
	 * Returns syllable information for a word.
	 *
	* @param string $word Word to get syllables for (required)
	* @param string $sourceDictionary Get from a single dictionary. Valid options: ahd, century, wiktionary, webster, and wordnet. (optional)
	* @param string $useCanonical If true will try to return a correct word root ('cats' -&gt; 'cat'). If false returns exactly what was requested. (optional)
	* @param int $limit Maximum number of results to return (optional)
	* @return array[Syllable]
	*/
	public function getHyphenation($word, $sourceDictionary=null, $useCanonical=null, $limit=null) {

		//parse inputs
		$resourcePath = "/word.{format}/{word}/hyphenation";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($useCanonical != null) {
			$queryParams['useCanonical'] = $this->apiClient->toQueryValue($useCanonical);
		}
		if($sourceDictionary != null) {
			$queryParams['sourceDictionary'] = $this->apiClient->toQueryValue($sourceDictionary);
		}
		if($limit != null) {
			$queryParams['limit'] = $this->apiClient->toQueryValue($limit);
		}
		if($word != null) {
			$resourcePath = str_replace("{" . "word" . "}", $this->apiClient->toPathValue($word), $resourcePath);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'array[Syllable]');
		
	}
	
	/**
	 * Returns word usage over time.
	 *
	* @param string $word Word to return (required)
	* @param string $useCanonical If true will try to return the correct word root ('cats' -&gt; 'cat'). If false returns exactly what was requested. (optional)
	* @param int $startYear Starting Year (optional)
	* @param int $endYear Ending Year (optional)
	* @return FrequencySummary
	*/
	public function getWordFrequency($word, $useCanonical=null, $startYear=null, $endYear=null) {

		//parse inputs
		$resourcePath = "/word.{format}/{word}/frequency";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($useCanonical != null) {
			$queryParams['useCanonical'] = $this->apiClient->toQueryValue($useCanonical);
		}
		if($startYear != null) {
			$queryParams['startYear'] = $this->apiClient->toQueryValue($startYear);
		}
		if($endYear != null) {
			$queryParams['endYear'] = $this->apiClient->toQueryValue($endYear);
		}
		if($word != null) {
			$resourcePath = str_replace("{" . "word" . "}", $this->apiClient->toPathValue($word), $resourcePath);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'FrequencySummary');
		
	}
	
	/**
	 * Fetches bi-gram phrases for a word.
	 *
	* @param string $word Word to fetch phrases for (required)
	* @param int $limit Maximum number of results to return (optional)
	* @param int $wlmi Minimum WLMI for the phrase (optional)
	* @param string $useCanonical If true will try to return the correct word root ('cats' -&gt; 'cat'). If false returns exactly what was requested. (optional)
	* @return array[Bigram]
	*/
	public function getPhrases($word, $limit=null, $wlmi=null, $useCanonical=null) {

		//parse inputs
		$resourcePath = "/word.{format}/{word}/phrases";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($limit != null) {
			$queryParams['limit'] = $this->apiClient->toQueryValue($limit);
		}
		if($wlmi != null) {
			$queryParams['wlmi'] = $this->apiClient->toQueryValue($wlmi);
		}
		if($useCanonical != null) {
			$queryParams['useCanonical'] = $this->apiClient->toQueryValue($useCanonical);
		}
		if($word != null) {
			$resourcePath = str_replace("{" . "word" . "}", $this->apiClient->toPathValue($word), $resourcePath);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'array[Bigram]');
		
	}
	
	/**
	 * Fetches etymology data.
	 *
	* @param string $word Word to return (required)
	* @param string $useCanonical If true will try to return the correct word root ('cats' -&gt; 'cat'). If false returns exactly what was requested. (optional)
	* @return array[string]
	*/
	public function getEtymologies($word, $useCanonical=null) {

		//parse inputs
		$resourcePath = "/word.{format}/{word}/etymologies";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($useCanonical != null) {
			$queryParams['useCanonical'] = $this->apiClient->toQueryValue($useCanonical);
		}
		if($word != null) {
			$resourcePath = str_replace("{" . "word" . "}", $this->apiClient->toPathValue($word), $resourcePath);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'array[string]');
		
	}
	
	/**
	 * Fetches audio metadata for a word..
	 *
	* @param string $word Word to get audio for. (required)
	* @param string $useCanonical Use the canonical form of the word (optional)
	* @param int $limit Maximum number of results to return (optional)
	* @return array[AudioFile]
	*/
	public function getAudio($word, $useCanonical=null, $limit=null) {

		//parse inputs
		$resourcePath = "/word.{format}/{word}/audio";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($useCanonical != null) {
			$queryParams['useCanonical'] = $this->apiClient->toQueryValue($useCanonical);
		}
		if($limit != null) {
			$queryParams['limit'] = $this->apiClient->toQueryValue($limit);
		}
		if($word != null) {
			$resourcePath = str_replace("{" . "word" . "}", $this->apiClient->toPathValue($word), $resourcePath);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'array[AudioFile]');
		
	}
	
	/**
	 * Returns the Scrabble score for a word.
	 *
	* @param string $word Word to get scrabble score for. (required)
	* @return ScrabbleScoreResult
	*/
	public function getScrabbleScore($word) {

		//parse inputs
		$resourcePath = "/word.{format}/{word}/scrabbleScore";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($word != null) {
			$resourcePath = str_replace("{" . "word" . "}", $this->apiClient->toPathValue($word), $resourcePath);
		}
		//make the API Call
		if (!isset($body)) {
			$body = null;
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);
		if(!$response){
			return null;
		}

		return $this->apiClient->deserialize($response, 'ScrabbleScoreResult');
		
	}
	
	}

