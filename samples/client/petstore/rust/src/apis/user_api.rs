/* 
 * Swagger Petstore
 *
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: apiteam@swagger.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use hyper;
use hyper::header::{HeaderName, HeaderValue};
use hyper::rt::{Future, Stream};
use serde_json;

use super::{Error, configuration};

pub struct UserApiClient<'a, C: hyper::client::connect::Connect> {
    configuration: &'a configuration::Configuration<C>,
}

impl<'a, C: hyper::client::connect::Connect> UserApiClient<'a, C> {
    pub fn new(configuration: &'a configuration::Configuration<C>) -> UserApiClient<'a, C> {
        UserApiClient {
            configuration: configuration,
        }
    }
}

pub trait UserApi {
    fn create_user(&self, body: ::models::User) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn create_users_with_array_input(&self, body: Vec<::models::User>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn create_users_with_list_input(&self, body: Vec<::models::User>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn delete_user(&self, username: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn get_user_by_name(&self, username: &str) -> Box<dyn Future<Item = ::models::User, Error = Error<serde_json::Value>>>;
    fn login_user(&self, username: &str, password: &str) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn logout_user(&self, ) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn update_user(&self, username: &str, body: ::models::User) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
}

impl<'a, C: hyper::client::connect::Connect>UserApi for UserApiClient<'a, C> where C: 'static {
    fn create_user(&self, body: ::models::User) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let method = hyper::Method::POST;
        let serialized = serde_json::to_string(&body).unwrap();
        let len = serialized.len();


        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user?{}", self.configuration.base_path, query_string);

        let mut req = hyper::Request::new(hyper::Body::from(serialized));
        *req.method_mut() = method.clone();

        let uri: hyper::Uri = uri_str.parse().unwrap();
        *req.uri_mut() = uri.clone();

        if let Some(ref user_agent) = self.configuration.user_agent {
            req.headers_mut().insert(hyper::header::CONTENT_TYPE, HeaderValue::from_str(&user_agent).unwrap());
        }



        req.headers_mut().insert(hyper::header::CONTENT_TYPE, HeaderValue::from_static("application/json"));
        req.headers_mut().insert(hyper::header::CONTENT_LENGTH, HeaderValue::from_str(&len.to_string()).unwrap());

        // send request
        Box::new(
        self.configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.into_body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn create_users_with_array_input(&self, body: Vec<::models::User>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let method = hyper::Method::POST;
        let serialized = serde_json::to_string(&body).unwrap();
        let len = serialized.len();


        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/createWithArray?{}", self.configuration.base_path, query_string);

        let mut req = hyper::Request::new(hyper::Body::from(serialized));
        *req.method_mut() = method.clone();

        let uri: hyper::Uri = uri_str.parse().unwrap();
        *req.uri_mut() = uri.clone();

        if let Some(ref user_agent) = self.configuration.user_agent {
            req.headers_mut().insert(hyper::header::CONTENT_TYPE, HeaderValue::from_str(&user_agent).unwrap());
        }



        req.headers_mut().insert(hyper::header::CONTENT_TYPE, HeaderValue::from_static("application/json"));
        req.headers_mut().insert(hyper::header::CONTENT_LENGTH, HeaderValue::from_str(&len.to_string()).unwrap());

        // send request
        Box::new(
        self.configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.into_body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn create_users_with_list_input(&self, body: Vec<::models::User>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let method = hyper::Method::POST;
        let serialized = serde_json::to_string(&body).unwrap();
        let len = serialized.len();


        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/createWithList?{}", self.configuration.base_path, query_string);

        let mut req = hyper::Request::new(hyper::Body::from(serialized));
        *req.method_mut() = method.clone();

        let uri: hyper::Uri = uri_str.parse().unwrap();
        *req.uri_mut() = uri.clone();

        if let Some(ref user_agent) = self.configuration.user_agent {
            req.headers_mut().insert(hyper::header::CONTENT_TYPE, HeaderValue::from_str(&user_agent).unwrap());
        }



        req.headers_mut().insert(hyper::header::CONTENT_TYPE, HeaderValue::from_static("application/json"));
        req.headers_mut().insert(hyper::header::CONTENT_LENGTH, HeaderValue::from_str(&len.to_string()).unwrap());

        // send request
        Box::new(
        self.configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.into_body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn delete_user(&self, username: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let method = hyper::Method::DELETE;


        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/{username}?{}", self.configuration.base_path, query_string, username=username);

        let mut req = hyper::Request::new(hyper::Body::empty());
        *req.method_mut() = method.clone();

        let uri: hyper::Uri = uri_str.parse().unwrap();
        *req.uri_mut() = uri.clone();

        if let Some(ref user_agent) = self.configuration.user_agent {
            req.headers_mut().insert(hyper::header::CONTENT_TYPE, HeaderValue::from_str(&user_agent).unwrap());
        }




        // send request
        Box::new(
        self.configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.into_body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn get_user_by_name(&self, username: &str) -> Box<dyn Future<Item = ::models::User, Error = Error<serde_json::Value>>> {
        let method = hyper::Method::GET;


        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/{username}?{}", self.configuration.base_path, query_string, username=username);

        let mut req = hyper::Request::new(hyper::Body::empty());
        *req.method_mut() = method.clone();

        let uri: hyper::Uri = uri_str.parse().unwrap();
        *req.uri_mut() = uri.clone();

        if let Some(ref user_agent) = self.configuration.user_agent {
            req.headers_mut().insert(hyper::header::CONTENT_TYPE, HeaderValue::from_str(&user_agent).unwrap());
        }




        // send request
        Box::new(
        self.configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.into_body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::User, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn login_user(&self, username: &str, password: &str) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let method = hyper::Method::GET;


        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("username", &username.to_string());
            query.append_pair("password", &password.to_string());
            query.finish()
        };
        let uri_str = format!("{}/user/login?{}", self.configuration.base_path, query_string);

        let mut req = hyper::Request::new(hyper::Body::empty());
        *req.method_mut() = method.clone();

        let uri: hyper::Uri = uri_str.parse().unwrap();
        *req.uri_mut() = uri.clone();

        if let Some(ref user_agent) = self.configuration.user_agent {
            req.headers_mut().insert(hyper::header::CONTENT_TYPE, HeaderValue::from_str(&user_agent).unwrap());
        }




        // send request
        Box::new(
        self.configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.into_body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<String, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn logout_user(&self, ) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let method = hyper::Method::GET;


        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/logout?{}", self.configuration.base_path, query_string);

        let mut req = hyper::Request::new(hyper::Body::empty());
        *req.method_mut() = method.clone();

        let uri: hyper::Uri = uri_str.parse().unwrap();
        *req.uri_mut() = uri.clone();

        if let Some(ref user_agent) = self.configuration.user_agent {
            req.headers_mut().insert(hyper::header::CONTENT_TYPE, HeaderValue::from_str(&user_agent).unwrap());
        }




        // send request
        Box::new(
        self.configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.into_body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn update_user(&self, username: &str, body: ::models::User) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let method = hyper::Method::PUT;
        let serialized = serde_json::to_string(&body).unwrap();
        let len = serialized.len();


        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/{username}?{}", self.configuration.base_path, query_string, username=username);

        let mut req = hyper::Request::new(hyper::Body::from(serialized));
        *req.method_mut() = method.clone();

        let uri: hyper::Uri = uri_str.parse().unwrap();
        *req.uri_mut() = uri.clone();

        if let Some(ref user_agent) = self.configuration.user_agent {
            req.headers_mut().insert(hyper::header::CONTENT_TYPE, HeaderValue::from_str(&user_agent).unwrap());
        }



        req.headers_mut().insert(hyper::header::CONTENT_TYPE, HeaderValue::from_static("application/json"));
        req.headers_mut().insert(hyper::header::CONTENT_LENGTH, HeaderValue::from_str(&len.to_string()).unwrap());

        // send request
        Box::new(
        self.configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.into_body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

}
