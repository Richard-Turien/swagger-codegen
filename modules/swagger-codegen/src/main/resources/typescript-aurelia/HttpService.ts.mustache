{{>licenseInfo}}
import { LogManager }
  from 'aurelia-framework';

import { HttpClient, HttpResponseMessage, RequestBuilder }
  from 'aurelia-http-client';

import { Logger }
  from 'aurelia-logging';

import { TokenService }
  from './TokenService';

const BASE_PATH = '{{{basePath}}}'
  .replace(/^(https?:\/\/)?[^\/]+/, '')
  .replace(/\/+$/, '');

/**
 * Class to handle http requests
 */
export class HttpService {

  private static logger: Logger;
  private static client: HttpClient;

  /**
   * Returns logger object.
   */
  private static getLogger(name?: string): Logger {
    return this.logger || (this.logger = LogManager.getLogger(name || 'HttpService'));
  }

  /**
   * Returns HTTP client.
   */
  public static getClient(): HttpClient {
    if (!this.client) {
      this.client = new HttpClient();
      this.client.configure((builder) => {
        builder
          .withBaseUrl(BASE_PATH)
          .withInterceptor({
            response(message: HttpResponseMessage): HttpResponseMessage {
              const { headers } = message;

              const csrfToken = headers.get('XSRF-TOKEN');
              csrfToken && TokenService.setCsrfToken(csrfToken);

              return message;
            },
          })
        ;
      });
    }

    return this.client;
  }

  /**
   * Creates request.
   */
  public static createRequest(url: string): RequestBuilder {
    return HttpService.getClient().createRequest(url);
  }

  /**
   * Adds the authorization header to the request.
   */
  public static async addAuthHeader(token: string, header: string, req: RequestBuilder): Promise<RequestBuilder> {
    const logger = this.getLogger();

    if (token === 'UserToken') {
      if (!TokenService.getUserToken()) {
        try {
          logger.info('Reload user token.');
          await TokenService.reloadUserToken();
          logger.info('Reloaded user token.');
        } catch (e) {
          logger.error('Reloading user token failed.', e);
          throw e;
        }
      }

      return req.withHeader(header, `Bearer ${TokenService.getUserToken()}`);
    }

    if (token === 'RefreshToken') {
      if (!TokenService.getRefreshToken()) {
        try {
          logger.info('Reload refresh token.');
          await TokenService.reloadRefreshToken();
          logger.info('Reloaded refresh token.');
        } catch (e) {
          logger.error('Reloading refresh token failed.', e);
          throw e;
        }
      }

      return req.withHeader(header, `Bearer ${TokenService.getRefreshToken()}`);
    }

    if (token === 'CsrfToken') {
      if (!TokenService.getCsrfToken()) {
        try {
          logger.info('Reload CSRF token.');
          await TokenService.reloadCsrfToken();
          logger.info('Reloaded CSRF token.');
        } catch (e) {
          logger.error('Reloading CSRF token failed.', e);
          throw e;
        }
      }

      const csrfToken = TokenService.getCsrfToken();
      TokenService.clearCsrfToken();

      return req.withHeader(header, csrfToken);
    }

    return req;
  }

  /**
   * Adds the authorization param to the request.
   */
  public static async addAuthParam(token: string, param: string, req: RequestBuilder): Promise<RequestBuilder> {
    const logger = this.getLogger();

    if (token === 'UserToken') {
      if (!TokenService.getUserToken()) {
        try {
          logger.info('Reload user token.');
          await TokenService.reloadUserToken();
          logger.info('Reloaded user token.');
        } catch (e) {
          logger.error('Reloading user token failed.', e);
          throw e;
        }
      }

      const params = {};
      params[param] = TokenService.getUserToken();

      return req.withParams(params);
    }

    if (token === 'RefreshToken') {
      if (!TokenService.getRefreshToken()) {
        try {
          logger.info('Reload refresh token.');
          await TokenService.reloadRefreshToken();
          logger.info('Reloaded refresh token.');
        } catch (e) {
          logger.error('Reloading refresh token failed.', e);
          throw e;
        }
      }

      const params = {};
      params[param] = TokenService.getRefreshToken();

      return req.withParams(params);
    }

    if (token === 'CsrfToken') {
      if (!TokenService.getCsrfToken()) {
        try {
          logger.info('Reload CSRF token.');
          await TokenService.reloadCsrfToken();
          logger.info('Reloaded CSRF token.');
        } catch (e) {
          logger.error('Reloading CSRF token failed:', e);
          throw e;
        }
      }

      const csrfToken = TokenService.getCsrfToken();
      TokenService.clearCsrfToken();

      const params = {};
      params[param] = csrfToken;

      return req.withParams(params);
    }

    return req;
  }

  /**
   * Returns URL origin.
   */
  public static getOrigin(): string {
    const { location } = window;
    const { origin }   = location;

    if (!origin) {
      const hostname = location.hostname;
      const protocol = location.protocol && `${location.protocol}//`;
      const port     = location.port     && `:${location.port}`;

      return `${protocol}${hostname}${port}`;
    }

    return origin;
  }

  /**
   * Returns URI prefix.
   */
  public static getPrefix(): string {
    const { location } = window;
    const { pathname } = location;

    const prefix = pathname.replace(/^\/*/, '');

    return prefix.startsWith('app_dev.php') ? '/app_dev.php' : '';
  }

  /**
   * Returns URL location with origin and prefix.
   */
  public static getLocation(): string {
    return `${this.getOrigin()}${this.getPrefix()}`;
  }

}
