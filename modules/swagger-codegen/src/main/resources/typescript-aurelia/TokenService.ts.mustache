import { LogManager }
  from 'aurelia-framework';

import { Logger }
  from 'aurelia-logging';

import { BehaviorSubject }
  from 'rxjs';

import * as jwt
  from 'jsonwebtoken';

import { HttpService }
  from './HttpService';

export interface TokenStorageInterface {
  [name: string]: BehaviorSubject<string | null>;
}

export class TokenService {

  private static logger:         Logger;
  private static tokens:         TokenStorageInterface;
  private static csrfPromise:    Promise<string>;
  private static userPromise:    Promise<string>;
  private static refreshPromise: Promise<string>;

  /**
   * Reloads refresh token from the API server.
   */
  public static async reloadRefreshToken(): Promise<string> {
    if (this.refreshPromise) {
      await this.refreshPromise;
      return this.getRefreshToken();
    }

    const logger = this.getLogger();
    logger.info('Reloading refresh token.');

    try {
      this.refreshPromise = new Promise<string>(async (resolve, reject) => {
        const request = HttpService
          .getClient()
          .createRequest(`/security/refresh-token`)
          .asPost()
        ;

        // Authentication 'CSRF token' required
        await HttpService.addAuthHeader('XSRF-TOKEN', 'CsrfToken', request);

        // Send the request
        const response = await request.send();

        if (response.statusCode < 200 || response.statusCode >= 300) {
          throw reject(response.content);
        }

        // Resolve the content
        return resolve(response.content);
      });

      const jwt = await this.refreshPromise;
      this.setRefreshToken(jwt);

      return this.getRefreshToken();
    } catch (e) {
      logger.error('Reloading refresh token failed:', e);

      if (e.statusCode > 399) {
        this.setRefreshToken(null);
        window.location.href = '/login';
      }

      throw e;
    } finally {
      this.refreshPromise = null;
    }
  }

  /**
   * Reloads user token from the API server.
   */
  public static async reloadUserToken(): Promise<string> {
    const logger = this.getLogger();
    logger.info('Reloading user token.');

    if (this.userPromise) {
      await this.userPromise;
      return this.getUserToken();
    }

    const refreshToken = this.getRefreshToken();

    if (!refreshToken) {
      logger.warn('Refresh token is missing.');

      this.setUserToken(null);

      return Promise.reject('Refresh token is missing.');
    }

    try {
      this.userPromise = new Promise<string>(async (resolve, reject) => {
        const request = HttpService
          .getClient()
          .createRequest(`/security/user-token`)
          .asPost()
        ;

        // Authentication 'RefreshToken' required
        await HttpService.addAuthHeader('RefreshToken', 'authorization', request);

        // Send the request
        const response = await request.send();

        if (response.statusCode < 200 || response.statusCode >= 300) {
          throw reject(response.content);
        }

        // Extract the content
        return resolve(response.content);
      });

      const jwt = await this.userPromise;
      this.setUserToken(jwt);

      return this.getUserToken();
    } catch (e) {
      logger.error('Reloading user token failed:', e);

      if (e.statusCode > 399) {
        this.setUserToken(null);
        window.location.href = '/login';
      }

      throw e;
    } finally {
      this.userPromise = null;
    }
  }


  /**
   * Refreshes token from the API server.
   */
  public static async reloadCsrfToken(): Promise<string> {
    const logger = this.getLogger();
    logger.info('Reloading CSRF token.');

    if (this.csrfPromise) {
      await this.csrfPromise;
      return this.getCsrfToken();
    }

    this.setCsrfToken(null);

    try {
      this.csrfPromise = new Promise<string>(async (resolve, reject) => {
        const request = HttpService
          .getClient()
          .createRequest(`/security/csrf-token`)
          .asHead()
        ;

        // Send the request
        const response = await request.send();

        if (response.statusCode < 200 || response.statusCode >= 300) {
          throw reject(response.content);
        }

        // Extract the content
        return resolve(response.content);
      });

      await this.csrfPromise;

      return this.getCsrfToken();
    } catch (e) {
      logger.error('Reloading CSRF token failed:', e);
      throw e;
    } finally {
      this.csrfPromise = null;
    }
  }

  /**
   * Returns token subjects.
   */
  public static getTokens(): TokenStorageInterface {
    if (!this.tokens) {
      this.tokens = { csrf: null, refresh: null, user: null };

      const initFromCache = ['refresh', 'user'];
      initFromCache.forEach((name) => this.initFromCache(name));

      const initWithNull = ['csrf'];
      initWithNull.forEach((name) => this.initWithNull(name));
    }

    return this.tokens;
  }

  /**
   * Return the CSRF token subject.
   */
  public static getCsrfTokenSubject(): BehaviorSubject<string | null> {
    return this.getTokens().csrf;
  }

  /**
   * Returns value of the CSRF token.
   */
  public static getCsrfToken(): string | null {
    return this.getCsrfTokenSubject().getValue();
  }

  /**
   * Changes value of the CSRF token.
   */
  public static setCsrfToken(token: string | null): void {
    const logger = this.getLogger();
    logger.debug('Setting CSRF token:', token);

    this.getCsrfTokenSubject().next(token);
  }

  /**
   * Clears value of the CSRF token.
   */
  public static clearCsrfToken(): void {
    const logger = this.getLogger();
    logger.info('Clearing CSRF token.');

    this.getCsrfTokenSubject().next(null);
  }

  /**
   * Return the refresh token subject.
   */
  public static getRefreshTokenSubject(): BehaviorSubject<string | null> {
    const { refresh } = this.getTokens();
    const value = refresh.getValue();

    if (value) {
      const logger = this.getLogger();
      logger.info('Refresh token found.');

      const decoded: any = jwt.decode(value);

      if (!decoded) {
        logger.info('Refresh token is invalid.');

        this.flushRefreshToken();
        refresh.next(null);

        // Must be after flush
        this.setUserToken(null);

        return refresh;
      }

      const duration = decoded.dur || false;

      if (!duration) {
        logger.info('Refresh token is missing duration.');

        this.flushRefreshToken();
        refresh.next(null);

        // Must be after flush
        this.setUserToken(null);

        return refresh;
      }

      const received = localStorage.getItem('unix_refresh');

      if (!received) {
        logger.info('Refresh token received at timestamp is missing.');

        this.flushRefreshToken();
        refresh.next(null);

        // Must be after flush
        this.setUserToken(null);

        return refresh;
      }

      const exp = parseInt(received) + parseInt(duration);
      const now = Math.round((new Date()).getTime() / 1000);

      //logger.debug('dur:', dur, 'exp:', exp, 'now:', now);

      if (exp < now - 5 * 60) {
        logger.info('Refresh token has expired.');

        this.flushRefreshToken();
        refresh.next(null);

        // Must be after flush
        this.setUserToken(null);

        return refresh;
      }
    }

    return refresh;
  }

  /**
   * Returns value of the refresh token.
   */
  public static getRefreshToken(): string | null {
    return this.getRefreshTokenSubject().getValue();
  }

  /**
   * Changes value of the refresh token.
   */
  public static setRefreshToken(token: string | null): void {
    const logger = this.getLogger();
    logger.debug('Setting refresh token:', token);

    const decoded: any = jwt.decode(token);

    if (decoded) {
      const now = Math.round((new Date()).getTime() / 1000);

      this.saveToCache('token_refresh', token);
      this.saveToCache('unix_refresh', now.toString());

      // Must be after save
      this.getRefreshTokenSubject().next(token);
    } else {
      this.flushRefreshToken();
      this.setUserToken(null);

      // Must be after flush
      this.getRefreshTokenSubject().next(null);
    }
  }

  /**
   * Flushes value of the refresh token.
   */
  public static flushRefreshToken(): void {
    this.clearFromCache('token_refresh');
    this.clearFromCache('unix_refresh');
  }

  /**
   * Return the user token subject.
   */
  public static getUserTokenSubject(): BehaviorSubject<string | null> {
    const { user } = this.getTokens();
    const value = user.getValue();

    if (value) {
      const logger = this.getLogger();
      logger.info('User token found.');

      const decoded: any = jwt.decode(value);

      if (!decoded) {
        logger.info('User token is invalid.');

        this.flushUserToken();

        // Must be after flush
        user.next(null);

        return user;
      }

      const duration = decoded.dur || false;

      if (!duration) {
        logger.info('User token is missing duration.');

        this.flushUserToken();

        // Must be after flush
        user.next(null);

        return user;
      }

      const received = localStorage.getItem('unix_user');

      if (!received) {
        logger.info('User token received at timestamp is missing.');

        this.flushUserToken();

        // Must be after flush
        user.next(null);

        return user;
      }

      const exp = parseInt(received) + parseInt(duration);
      const now = Math.round((new Date()).getTime() / 1000);

      if (exp < now - 30) {
        logger.info('User token has expired.');

        this.flushUserToken();

        // Must be after flush
        user.next(null);

        return user;
      }
    }

    return user;
  }

  /**
   * Returns value of the user token.
   */
  public static getUserToken(): string | null {
    return this.getUserTokenSubject().getValue();
  }

  /**
   * Changes value of the user token
   */
  public static setUserToken(token: string | null) {
    const logger = this.getLogger();
    logger.debug('Setting user token:', token);

    const decoded: any = jwt.decode(token);

    if (decoded) {
      const now = Math.round((new Date()).getTime() / 1000);

      this.saveToCache('token_user', token);
      this.saveToCache('unix_user', now.toString());

      // Must be after save
      this.getUserTokenSubject().next(token);
    } else {
      this.flushUserToken();

      // Must be after flush
      this.getUserTokenSubject().next(null);
    }
  }

  /**
   * Clears value of the user token.
   */
  public static flushUserToken(): void {
    this.clearFromCache('token_user');
    this.clearFromCache('unix_user');
  }

  /**
   * Returns logger object.
   */
  private static getLogger(name?: string): Logger {
    return this.logger || (this.logger = LogManager.getLogger(name || 'TokenService'));
  }

  /**
   * Load token from the cache.
   */
  private static loadFromCache(key: string): string | null {
    const value = localStorage.getItem(key);

    const logger = this.getLogger();
    logger.debug('Loaded from cache:', key);

    return value;
  }

  /**
   * Store token to the cache.
   */
  private static saveToCache(key: string, value: string | null): void {
    const logger = this.getLogger();
    logger.debug('Saving to cache:', key);

    localStorage.setItem(key, value);
  }

  /**
   * Remove token from the cache.
   */
  private static clearFromCache(key: string): void {
    const logger = this.getLogger();
    logger.debug('Clearing from cache:', key);

    localStorage.removeItem(key);
  }

  /**
   * Initializes item with null value.
   */
  private static initWithNull(name: string): void {
    const logger = this.getLogger();
    logger.info('Initialize with NULL:', name);

    const tokens = this.getTokens();
    tokens[name] = new BehaviorSubject(null);
  }

  /**
   * Initializes item from the cache.
   */
  private static initFromCache(name: string): void {
    const logger = this.getLogger();
    logger.debug('Initialize from cache:', name);

    const tokens = this.getTokens();

    try {
      // Load token from cache
      const key   = `token_${name}`;
      const value = this.loadFromCache(key);

      // Create behavior subject with cached value
      tokens[name] = new BehaviorSubject(value);
    } catch (e) {
      logger.error('Loading from cache failed:', e);
      this.initWithNull(name);
    }
  }

}
