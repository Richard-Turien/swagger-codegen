// tslint:disable
{{>licenseInfo}}

import * as url                                 	    from "url";
import * as isomorphicFetch                     	    from "isomorphic-fetch";

const BASE_PATH = "{{{basePath}}}".replace(/\/+$/, "");

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<any>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    constructor(public basePath: string = BASE_PATH, public fetch: FetchAPI = isomorphicFetch) {
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

{{#models}}
{{#model}}
{{#isEnum}}{{>modelEnum}}{{/isEnum}}{{^isEnum}}{{>modelGeneric}}{{/isEnum}}
{{/model}}

{{/models}}
{{#apiInfo}}
{{#apis}}
{{#operations}}

/**
 * {{classname}} - fetch parameter creator{{#description}}
 * {{&description}}{{/description}}
 */
export const {{classname}}FetchParamCreator = {
{{#operation}}
    /**
     * {{&notes}}
     {{#summary}}
     * @summary {{&summary}}
     {{/summary}}
     {{#allParams}}
     * @param {{=<% %>=}}{<%dataType%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
     {{/allParams}}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options?: any): FetchArgs {
{{#allParams}}
{{#required}}
        // verify required parameter '{{paramName}}' is not null or undefined
        if ({{paramName}} === null || {{paramName}} === undefined) {
            throw new RequiredError('{{paramName}}','Required parameter {{paramName}} was null or undefined when calling {{nickname}}.');
        }
{{/required}}
{{/allParams}}
        const path = `{{{path}}}`{{#pathParams}}
            .replace(`{${"{{baseName}}"}}`, String({{paramName}})){{/pathParams}};
        const urlObj = url.parse(path, true);
        const headers = {} as any;
{{#hasQueryParams}}
        const queryParameters = {} as any;
{{/hasQueryParams}}
{{#hasFormParams}}
        const formParams = new url.URLSearchParams();
{{/hasFormParams}}

{{#queryParams}}
        {{#isListContainer}}
        if ({{paramName}}) {
        {{#isCollectionFormatMulti}}
            queryParameters['{{baseName}}'] = {{paramName}} as any;
        {{/isCollectionFormatMulti}}
        {{^isCollectionFormatMulti}}
            queryParameters['{{baseName}}'] = {{paramName}}.join(',');
        {{/isCollectionFormatMulti}}
        }
        {{/isListContainer}}
        {{^isListContainer}}
        if ({{paramName}} !== undefined) {
            {{#isDateTime}}
            queryParameters['{{baseName}}'] = ({{paramName}} as any).toISOString();
            {{/isDateTime}}
            {{^isDateTime}}
            {{#isDate}}
            queryParameters['{{baseName}}'] = ({{paramName}} as any).toISOString();
            {{/isDate}}
            {{^isDate}}
            queryParameters['{{baseName}}'] = {{paramName}} as any;
            {{/isDate}}
            {{/isDateTime}}
        }
        {{/isListContainer}}
{{/queryParams}}
{{#hasQueryParams}}
        urlObj.query = Object.assign({}, urlObj.query, queryParameters);
{{/hasQueryParams}}
{{#headerParams}}
        {{#isListContainer}}
        if ({{paramName}}) {
            headers['{{baseName}}'] = {{paramName}}.join(',');
        }
        {{/isListContainer}}
        {{^isListContainer}}
        if ({{paramName}} !== undefined && {{paramName}} !== null) {
            headers['{{baseName}}'] = String({{paramName}});
        }
        {{/isListContainer}}
{{/headerParams}}
{{#formParams}}
        {{#isListContainer}}
        if ({{paramName}}) {
        {{#isCollectionFormatMulti}}
            {{paramName}}.forEach((element) => {
                formParams.append('{{baseName}}', <any>element);
            })
        {{/isCollectionFormatMulti}}
        {{^isCollectionFormatMulti}}
                formParams.set('{{baseName}}', {{paramName}}.join(','));
        {{/isCollectionFormatMulti}}
        }
        {{/isListContainer}}
        {{^isListContainer}}
        if ({{paramName}} !== undefined) {
            formParams.set('{{baseName}}', <any>{{paramName}});
        }
        {{/isListContainer}}

{{/formParams}}
{{#hasFormParams}}
        headers['Content-Type'] = 'application/x-www-form-urlencoded';
{{/hasFormParams}}
{{#bodyParam}}
        headers['Content-Type'] = 'application/json';
{{/bodyParam}}

        let requestOptions = {
            method: '{{httpMethod}}',
            headers: headers,
{{#bodyParam}}
            body: {{paramName}} === null ? '' : JSON.stringify({{paramName}}),
{{/bodyParam}}
{{#hasFormParams}}
            body: formParams.toString(),
{{/hasFormParams}}
        } as any;
        if (options) {
            requestOptions = Object.assign(requestOptions, options);
        }

        return {
            url: url.format(urlObj),
            options: requestOptions,
        };
    },
{{/operation}}
};

/**
 * {{classname}} - functional programming interface{{#description}}
 * {{{description}}}{{/description}}
 */
export const {{classname}}Fp = {
{{#operation}}
    /**
     * {{&notes}}
     {{#summary}}
     * @summary {{&summary}}
     {{/summary}}
     {{#allParams}}
     * @param {{=<% %>=}}{<%dataType%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
     {{/allParams}}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}any{{/returnType}}> {
        const fetchArgs = {{classname}}FetchParamCreator.{{nickname}}({{#allParams}}{{paramName}}, {{/allParams}}options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response{{#returnType}}.json(){{/returnType}};
                } else {
                    throw response;
                }
            });
        };
    },
{{/operation}}
};

/**
 * {{classname}} - object-oriented interface{{#description}}
 * {{{description}}}{{/description}}
 * @export
 * @class {{classname}}
 * @extends {BaseAPI}
 */
export class {{classname}} extends BaseAPI {
{{#operation}}
    /**
     * {{&notes}}
     {{#summary}}
     * @summary {{&summary}}
     {{/summary}}
     {{#allParams}}
     * @param {{=<% %>=}}{<%dataType%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
     {{/allParams}}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof {{classname}}
     */
    public {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options?: any) {
        return {{classname}}Fp.{{nickname}}({{#allParams}}{{paramName}}, {{/allParams}}options)(this.fetch, this.basePath);
    }
{{/operation}}
};

/**
 * {{classname}} - factory interface{{#description}}
 * {{&description}}{{/description}}
 */
export const {{classname}}Factory = function (fetch?: FetchAPI, basePath?: string) {
    return {
{{#operation}}
        /**
         * {{&notes}}
         {{#summary}}
         * @summary {{&summary}}
         {{/summary}}
         {{#allParams}}
         * @param {{=<% %>=}}{<%dataType%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
         {{/allParams}}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options?: any) {
            return {{classname}}Fp.{{nickname}}({{#allParams}}{{paramName}}, {{/allParams}}options)(fetch, basePath);
        },
{{/operation}}
    };
};

{{/operations}}
{{/apis}}
{{/apiInfo}}