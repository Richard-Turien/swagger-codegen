{{#operations}}//
// {{classname}}.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Alamofire
import ObjectMapper

{{#description}}
/** {{description}} */{{/description}}
class {{classname}} {
{{#operation}}

    enum {{operationId}}Response {
        {{#responses}}case Res{{code}}({{#dataType}}{{.}}, {{/dataType}}NSData){{#isDefault}}//default{{/isDefault}}
        {{/responses}}case Failure(Int?, NSData?)
        var data:NSData? {
            switch self {
            {{#responses}}case Res{{code}}({{#dataType}}_, {{/dataType}}let nsdata):
                return nsdata
            {{/responses}}case Failure(_, let nsdata):
                return nsdata
            }
        }
        var statusCode:Int? {
            switch self {
            {{#responses}}case Res{{code}}:
                return {{code}}
            {{/responses}}case Failure(let code, _):
                return code
            }
        }
    }

    /**
     {{#summary}}
     {{{summary}}}
     {{/summary}}
     - {{httpMethod}} {{path}}{{#notes}}
     - {{{notes}}}{{/notes}}
     */
    class func request{{operationId}}({{#allParams}}{{paramName}}: {{#isListContainer}}[{{/isListContainer}}{{{dataType}}}{{#isListContainer}}]{{/isListContainer}}{{^required}}?{{/required}}, {{/allParams}}callback:(({{operationId}}Response) -> Void)?=nil) {
        {{^pathParams}}let{{/pathParams}}{{#pathParams}}{{^secondaryParam}}var{{/secondaryParam}}{{/pathParams}} path = "{{path}}"{{#pathParams}}
        path = path.stringByReplacingOccurrencesOfString("{{=<% %>=}}{<%paramName%>}<%={{ }}=%>", withString: "\({{paramName}})", options: .LiteralSearch, range: nil){{/pathParams}}
        let URLString = "{{basePath}}" + path
        
        let headerParams:[String:String]? = {{^headerParams}}nil{{/headerParams}}{{#headerParams}}{{^secondaryParam}}[{{/secondaryParam}}
            "{{baseName}}": {{#required}}"\({{paramName}})"{{/required}}{{^required}}{{paramName}} == nil ? "" : "\({{paramName}})"!{{/required}}{{#hasMore}},{{/hasMore}}{{^hasMore}}
        ]{{/hasMore}}{{/headerParams}}

        {{#bodyParam}}
        let data:NSData
        if let {{^required}}{{paramName}} = {{paramName}}, {{/required}}dataString = Mapper().toJSONString({{paramName}}), encodedData = dataString.dataUsingEncoding(NSUTF8StringEncoding) {
            data = encodedData
        } else {
            data = NSData()
        }
        {{/bodyParam}}
        {{^bodyParam}}
        let queryParams = APIHelper.prepareParameters({{^queryParams}}nil{{/queryParams}}{{#queryParams}}{{^secondaryParam}}[{{/secondaryParam}}
            "{{baseName}}": {{paramName}}{{#hasMore}},{{/hasMore}}{{^hasMore}}
        ]{{/hasMore}}{{/queryParams}})
        
        Alamofire.request(Method.{{httpMethod}}, URLString, parameters: queryParams, encoding: .URL, headers: headerParams){{/bodyParam}}{{#bodyParam}}        Alamofire.upload(Method.{{httpMethod}}, URLString, headers: headerParams, data: data){{/bodyParam}}.response { (urlRequest, nshttpUrlResponse, data, err) in
            guard let callback = callback else {
                return
            }
            guard let nshttpUrlResponse = nshttpUrlResponse, data = data else {
                callback(.Failure(nil, nil))
                return
            }
            switch nshttpUrlResponse.statusCode {
            {{#responses}}
            case {{code}}:{{#dataType}}{{#primitiveType}}
                let responseSerializer = Request.stringResponseSerializer()
                {{/primitiveType}}{{^primitiveType}}{{#containerType}}
                let responseSerializer:ResponseSerializer<{{dataType}}, NSError> = Request.ObjectMapperArraySerializer("")
                {{/containerType}}{{^containerType}}
                let responseSerializer:ResponseSerializer<{{dataType}}, NSError> = Request.ObjectMapperSerializer("")
                {{/containerType}}{{/primitiveType}}
                let result = responseSerializer.serializeResponse(urlRequest, nshttpUrlResponse, data, err)
                if let value = result.value {
                    callback(.Res{{code}}(value, data))
                } else {
                    callback(.Failure({{code}}, data))
                }
                {{/dataType}}{{^dataType}}callback(.Res{{code}}(data)){{/dataType}}
                break
            {{/responses}}
            default:
                callback(.Failure(nshttpUrlResponse.statusCode, data))
                break
            }
        }
    }

{{/operation}}
}   
{{/operations}}
